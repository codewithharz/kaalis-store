<template>
  <div class="bg-white pb-2 mt-2">
    <h4
      class="flex flex-col sm:flex-row sm:items-center justify-between py-4 px-5 text-xs font-medium text-[#212121] border-b-[1px] w-full">
      <span class="mb-2 sm:mb-0">
        <!-- e.g., "D182CF" -->
        <span class="flex text-sm font-semibold">
          <p class="pr-1">Order ID:</p>
          <a href="#" class="text-[#24a3b5] hover:text-[#24a3b5]">215486007</a>
        </span>
        <p>Order Placed on Fri, 19 Jul 2024</p>
      </span>

      <span class="text-sm">
        <a href="#"
          class="inline-block text-[#ff934b] hover:text-[#ff934b] font-normal text-sm shadow-md border-[1px] border-[#ff934b] px-4 py-2 rounded-sm">
          Order details
        </a>
      </span>
    </h4>

    <div class="flex flex-col sm:flex-row m-5">
      <div class="mb-4 sm:mb-0">
        <div class="border-[1px] w-28 border-[#aaa] mx-auto sm:mx-0">
          <a href="#" target="_blank">
            <img src="https://images.shopclues.com/images1/thumbnails/116607/320/320/89890689-116607429-1663670590.jpg"
              alt="phone" class="w-full h-auto">
          </a>
        </div>
      </div>

      <div class="flex flex-col sm:flex-row justify-between w-full sm:pl-7">
        <div class="space-y-3 mb-4 sm:mb-0">
          <h3>
            <a href="" target="_blank" class="text-[#333] hover:text-[#333]">
              HOTLINE H310 (Dual Sim, 1.8 Inch Display, 1000 Mah Battery)
            </a>
          </h3>
          <p class="space-x-2 text-sm text-[#888]">
            <span>Total</span>
            <span class="pr-2 text-[#333]">38000</span> |
            <span>QTY</span>
            <span class="text-[#333]">2</span>
          </p>
          <span class="space-y-3">
            <span class="flex items-center text-sm space-x-2 mt-4">
              <span class="font-semibold text-[#222]">Cod:</span>
              <span class="font-medium text-[#444] pr-1">38000</span>
              <a href="#"
                class="button-hover text-xs py-1 px-2 bg-gradient-to-t from-[#ff934b] to-[#ff5e62] hover:from-[#ff5e62] hover:to-[#ff934b] text-white hover:text-white font-light rounded-sm focus:outline-none">
                Prepay Now
              </a>
            </span>
            <div>
              <p class="font-bold text-[#222]">Payment Pending</p>
            </div>
          </span>
        </div>
        <div class="text-sm space-y-4">
          <a href="#" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <Pencil class="text-white size-7 rounded-full bg-[#00bc75] p-[5px]" />
            Modify Order
          </a>
          <a href="#" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <MapPin class="text-white size-7 rounded-full bg-[#4478e5] p-[5px]" />
            Track Order
          </a>
          <a href="#" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <Phone class="text-white size-7 rounded-full bg-[#07b9c6] p-[5px]" />
            Customer Support
          </a>
          <a href="#" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <PrinterCheck class="text-white size-7 rounded-full bg-[#4478e5] p-[5px]" />
            Print Order Detail
          </a>
          <a href="#" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <X class="text-white size-7 rounded-full bg-[#ed2e2e] p-[5px]" />
            Cancel Order
          </a>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { useUserStore } from '../store/user';
import { computed } from 'vue';
import { Pencil, MapPin, Phone, PrinterCheck, X } from 'lucide-vue-next';

export default {
  name: 'ProfileOrderCard',
  components: {
    Pencil, MapPin, Phone, PrinterCheck, X,
  },
  setup() {
    const userStore = useUserStore();
    const user = computed(() => userStore.user); // Accessing the user data from the Pinia store
    console.log(user.value)
    return {
      user,
    };
  },
};
</script>

<style scoped>
/* Add any specific styles for this page */
</style>


====================v2==========================

<template>
  <div v-if="currentOrder" class="bg-white pb-2 mt-2">
    <h4
      class="flex flex-col sm:flex-row sm:items-center justify-between py-4 px-5 text-xs font-medium text-[#212121] border-b-[1px] w-full">
      <span class="mb-2 sm:mb-0">
        <span class="flex text-sm font-semibold">
          <p class="pr-1">Order ID:</p>
          <a href="#" class="text-[#24a3b5] hover:text-[#24a3b5]">
            {{ currentOrder.orderId }}
          </a>
        </span>
        <p>Order Placed on {{ formatDate(currentOrder.createdAt) }}</p>
      </span>

      <span class="text-sm">
        <a href="#" @click.prevent="viewOrderDetails"
          class="inline-block text-[#ff934b] hover:text-[#ff934b] font-normal text-sm shadow-md border-[1px] border-[#ff934b] px-4 py-2 rounded-sm">
          Order details
        </a>
      </span>
    </h4>

    <div class="flex flex-col sm:flex-row m-5">
      <div class="mb-4 sm:mb-0">
        <div class="border-[1px] w-28 border-[#aaa] mx-auto sm:mx-0">
          <a href="#" target="_blank">
            <img v-if="productDetails?.product" :src="productDetails.product.images?.[0] || '/placeholder-image.jpg'"
              :alt="productDetails.product.name" class="w-full h-auto">

          </a>
        </div>
      </div>

      <div class="flex flex-col sm:flex-row justify-between w-full sm:pl-7">
        <div class="space-y-3 mb-4 sm:mb-0">
          <h3>
            <a href="#" target="_blank" class="text-[#333] hover:text-[#333]">
              <!-- {{ getProductName() }}  -->
              {{ productDetails?.product?.name || 'Product Name Not Available' }}
            </a>
          </h3>
          <p class="space-x-2 text-sm text-[#888]">
            <span>Total</span>
            <span class="pr-2 text-[#333]">₦{{ formatAmount(currentOrder.totalAmount) }}</span> |
            <span>QTY</span>
            <span class="text-[#333]">{{ getTotalQuantity(currentOrder.products) }}</span>
          </p>
          <span class="space-y-3">
            <span class="flex items-center text-sm space-x-2 mt-4">
              <span class="font-semibold text-[#222]">{{ currentOrder.paymentMethod || 'Payment' }}:</span>
              <span class="font-medium text-[#444] pr-1">₦{{ formatAmount(currentOrder.totalAmount) }}</span>
              <a v-if="currentOrder.status === 'Pending'" href="#" @click.prevent="handlePayNow"
                class="button-hover text-xs py-1 px-2 bg-gradient-to-t from-[#ff934b] to-[#ff5e62] hover:from-[#ff5e62] hover:to-[#ff934b] text-white hover:text-white font-light rounded-sm focus:outline-none">
                Prepay Now
              </a>
            </span>
            <div>
              <p class="font-bold text-[#222]">{{ currentOrder.status }}</p>
            </div>
          </span>
        </div>
        <div class="text-sm space-y-4">
          <a v-if="canModifyOrder" href="#" @click.prevent="handleModifyOrder"
            class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <Pencil class="text-white size-7 rounded-full bg-[#00bc75] p-[5px]" />
            Modify Order
          </a>
          <a href="#" @click.prevent="handleTrackOrder" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <MapPin class="text-white size-7 rounded-full bg-[#4478e5] p-[5px]" />
            Track Order
          </a>
          <a href="#" @click.prevent="handleSupport" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <Phone class="text-white size-7 rounded-full bg-[#07b9c6] p-[5px]" />
            Customer Support
          </a>
          <a href="#" @click.prevent="handlePrintOrder" class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <PrinterCheck class="text-white size-7 rounded-full bg-[#4478e5] p-[5px]" />
            Print Order Detail
          </a>
          <a v-if="canCancelOrder" href="#" @click.prevent="handleCancelOrder"
            class="flex items-center gap-2 text-[#555] hover:text-[#555]">
            <X class="text-white size-7 rounded-full bg-[#ed2e2e] p-[5px]" />
            Cancel Order
          </a>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { useOrderStore } from '../store/orderStore';
import { useProductStore } from '../store/productStore.js';
import { useUserStore } from '../store/user';
import { computed, ref, onMounted } from 'vue';
import { Pencil, MapPin, Phone, PrinterCheck, X } from 'lucide-vue-next';
import { useRouter } from 'vue-router';

export default {
  name: 'ProfileOrderCard',
  components: {
    Pencil, MapPin, Phone, PrinterCheck, X,
  },
  props: {
    order: {
      type: Object,
      required: true
    }
  },
  setup(props, { emit }) {
    const orderStore = useOrderStore();
    const userStore = useUserStore();
    const productStore = useProductStore();
    const router = useRouter();
    const placeholderImage = '/placeholder-image.jpg';
    const productDetails = ref(null);

    const loadProductDetails = async () => {
      if (!currentOrder.value?.products?.length) return;

      const firstProduct = currentOrder.value.products[0];
      if (firstProduct && firstProduct.product && typeof firstProduct.product === 'string') {
        try {
          const details = await productStore.fetchProductById(firstProduct.product);
          productDetails.value = {
            ...firstProduct,
            product: details
          };
        } catch (error) {
          console.error('Error fetching product details:', error);
          productDetails.value = firstProduct;
        }
      }
    };

    // Call this when the component mounts
    onMounted(() => {
      loadProductDetails();
    });

    // Computed properties
    const currentOrder = computed(() => {
      console.log('Full order data:', JSON.stringify(props.order, null, 2));
      return props.order;
    });

    const getFirstProduct = computed(async () => {
      if (!currentOrder.value?.products?.length) {
        console.log('No products found in order');
        return null;
      }

      const firstProduct = currentOrder.value.products[0];
      console.log('First product in order:', firstProduct);

      // If we don't have the full product data, fetch it
      if (firstProduct && firstProduct.product && typeof firstProduct.product === 'string') {
        try {
          // Fetch full product details using the ID
          const productDetails = await productStore.fetchProductById(firstProduct.product);
          return {
            ...firstProduct,
            product: productDetails
          };
        } catch (error) {
          console.error('Error fetching product details:', error);
          return firstProduct;
        }
      }

      return firstProduct;
    });

    const canModifyOrder = computed(() =>
      currentOrder.value?.status === 'Pending'
    );

    const canCancelOrder = computed(() =>
      ['Pending', 'Processing'].includes(currentOrder.value?.status)
    );

    // Methods
    const getProductImage = () => {
      try {
        return currentOrder.value?.products?.[0]?.product?.images?.[0] || placeholderImage;
      } catch (error) {
        console.error('Error getting product image:', error);
        return placeholderImage;
      }
    };

    const getProductName = () => {
      try {
        return currentOrder.value?.products?.[0]?.product?.name || 'Product Name Not Available';
      } catch (error) {
        console.error('Error getting product name:', error);
        return 'Product Name Not Available';
      }
    };

    const formatDate = (date) => {
      if (!date) return 'Date not available';
      return new Date(date).toLocaleDateString('en-US', {
        weekday: 'short',
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    };

    const formatAmount = (amount) => {
      if (!amount) return '0.00';
      return amount.toLocaleString('en-NG', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
    };

    const getTotalQuantity = (products) => {
      if (!Array.isArray(products)) return 0;
      return products.reduce((total, item) => total + (item.quantity || 0), 0);
    };

    const handleModifyOrder = () => {
      if (!currentOrder.value?._id) return;
      router.push(`/orders/${currentOrder.value._id}/modify`);
    };

    const viewOrderDetails = () => {
      if (!currentOrder.value?._id) return;
      router.push(`/orders/${currentOrder.value._id}`);
    };

    const handleCancelOrder = async () => {
      if (!currentOrder.value?._id) return;
      if (confirm('Are you sure you want to cancel this order?')) {
        try {
          await orderStore.cancelOrder(currentOrder.value._id);
          emit('order-updated');
        } catch (error) {
          console.error('Error cancelling order:', error);
        }
      }
    };

    const handleTrackOrder = () => {
      if (!currentOrder.value?._id) return;
      router.push(`/orders/${currentOrder.value._id}/track`);
    };

    const handlePayNow = () => {
      if (!currentOrder.value?._id) return;
      router.push(`/checkout/${currentOrder.value._id}/payment`);
    };

    const handleSupport = () => {
      // Implement support logic
      console.log('Support clicked');
    };

    const handlePrintOrder = () => {
      window.print();
    };

    return {
      productDetails,
      loadProductDetails,
      currentOrder,
      getFirstProduct,
      user: computed(() => userStore.user),
      canModifyOrder,
      canCancelOrder,
      formatDate,
      formatAmount,
      getTotalQuantity,
      getProductImage,
      getProductName,
      handleCancelOrder,
      viewOrderDetails,
      handleModifyOrder,
      handleTrackOrder,
      handlePayNow,
      handleSupport,
      handlePrintOrder
    };
  }
};
</script>










=======================version-3==========================
// frontend/src/store/product.js
import { defineStore } from "pinia";
import apiClient from "../api/axios";
import axios from "axios";
import { useUserStore } from "./user";
import { toast } from "vue-sonner";

export const useProductStore = defineStore("product", {
  state: () => ({
    products: [],
    product: null,
    shippingRules: null,
    categories: [],
    filters: {
      unitCategory: null,
      unitRange: { min: null, max: null },
      color: null, // Add color to filters
    },
  }),

  getters: {
    flattenedCategories: (state) => {
      // Add a safety check
      if (!state.categories || state.categories.length === 0) {
        return [];
      }
      const flatten = (cats, prefix = "") =>
        cats.reduce((acc, cat) => {
          const newCat = { ...cat, name: prefix + cat.name };
          return acc.concat(
            newCat,
            flatten(cat.children || [], prefix + "-- ")
          );
        }, []);
      return flatten(state.categories);
    },
  },
  actions: {
    async fetchProducts() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await axios.get("/products", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
        this.shippingRules = response.data.shippingRules;
      } catch (error) {
        console.error("Error fetching products:", error);
        this.products = []; // Ensure it's an empty array if fetch fails
        this.shippingRules = null;
      }
    },

    async fetchProductById(id) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${id}`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (
          typeof response.data === "string" &&
          response.data.includes("<!doctype html>")
        ) {
          console.error("Received HTML instead of JSON:", response.data);
          throw new Error("Invalid response format");
        }

        console.log("Fetched product:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        throw error;
      }
    },

    async fetchCategories() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/categories", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.categories = this.buildCategoryTree(response.data);
        return this.categories;
      } catch (error) {
        console.error("Error fetching categories:", error);
        this.categories = []; // Ensure categories is an empty array if fetch fails
        throw error;
      }
    },

    async fetchRelatedProducts(
      productId,
      limit = 4,
      includeColorMatch = false
    ) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${productId}/related`, {
          params: { limit, includeColor: includeColorMatch },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        return response.data.relatedProducts;
      } catch (error) {
        console.error("Error fetching related products:", error);
        toast.error("Failed to load related products");
        return [];
      }
    },

    async fetchProductsWithFilters(filters) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        // Combine with existing filters
        const allFilters = {
          ...filters,
          color: filters.color || this.filters.color,
        };

        const response = await apiClient.get("/products", {
          params: filters,
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        // this.products = response.data;
        this.products = response.data.products;

        return response.data;
      } catch (error) {
        console.error("Error fetching products with filters:", error);
        this.products = [];
        throw error;
      }
    },

    async rateProduct(productId, rating, review) {
      try {
        const userStore = useUserStore();
        const response = await apiClient.post(
          `/products/${productId}/rate`,
          { rating, review },
          {
            headers: {
              Authorization: `Bearer ${userStore.token}`,
            },
          }
        );

        // Update the product in the local state if it exists
        const productIndex = this.products.findIndex(
          (p) => p._id === productId
        );
        if (productIndex !== -1) {
          this.products[productIndex] = {
            ...this.products[productIndex],
            ...response.data.product,
          };
        }

        toast.success("Product rated successfully");
        return response.data;
      } catch (error) {
        console.error("Error rating product:", error);
        toast.error("Failed to rate product");
        throw error;
      }
    },

    async fetchProductReviews(productId) {
      try {
        const response = await apiClient.get(`/products/${productId}/ratings`);
        return response.data;
      } catch (error) {
        console.error("Error fetching product reviews:", error);
        toast.error("Failed to load product reviews");
        throw error;
      }
    },

    async fetchRandomProducts(limit = 4, excludeId = null) {
      try {
        console.log(
          "Fetching random products with limit:",
          limit,
          "excludeId:",
          excludeId
        );
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: {
            random: true,
            limit,
            excludeId,
          },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        console.log("Received response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching random products:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        toast.error("Failed to load random products");
        return [];
      }
    },

    async fetchProductsByCategory(categorySlug) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        console.log(`Fetching products for category slug: ${categorySlug}`);
        const response = await apiClient.get(
          `/categories/slug/${categorySlug}/products`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        console.log("API response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching products by category:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
        }
        throw error;
      }
    },

    buildCategoryTree(categories) {
      const categoryMap = {};
      const rootCategories = [];

      // First pass: create a map of categories
      categories.forEach((category) => {
        categoryMap[category._id] = { ...category, children: [] };
      });

      // Second pass: build the tree structure
      categories.forEach((category) => {
        if (category.parent) {
          const parent = categoryMap[category.parent];
          if (parent) {
            parent.children.push(categoryMap[category._id]);
          }
        } else {
          rootCategories.push(categoryMap[category._id]);
        }
      });

      return rootCategories;
    },
    async suggestNewCategory(categoryName) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post(
          "/categories/suggest",
          { name: categoryName },
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("Suggested new category:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error suggesting new category:", error);
        throw error;
      }
    },

    async createProduct(productData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const userId = userStore.user._id;

        // Create a deep copy of the product data
        let plainProductData = JSON.parse(JSON.stringify(productData));

        // Ensure images array exists and is properly formatted
        plainProductData.images = Array.isArray(productData.images)
          ? productData.images
              .flat()
              .filter((url) => typeof url === "string" && url.trim() !== "")
              .map((url) => url.trim())
          : [];

        console.log("Sanitized images array:", plainProductData.images);
        console.log("Initial product data:", plainProductData);

        // Ensure images array exists
        if (!plainProductData.images) {
          plainProductData.images = [];
        }

        // Convert images to array if it's somehow not an array
        if (!Array.isArray(plainProductData.images)) {
          plainProductData.images = [plainProductData.images].filter(Boolean);
        }

        // Ensure images are properly formatted as an array of strings
        plainProductData.images = plainProductData.images
          .flat() // Flatten in case of nested arrays
          .filter((url) => typeof url === "string" && url.trim() !== "");

        console.log("Processed images array:", plainProductData.images);

        // Validate image URLs
        const validImageUrls = plainProductData.images.every((url) => {
          try {
            new URL(url);
            return true;
          } catch {
            return false;
          }
        });

        if (!validImageUrls) {
          throw new Error("Invalid image URLs detected");
        }

        // Color validation
        if (
          plainProductData.color &&
          typeof plainProductData.color === "string"
        ) {
          if (
            !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(plainProductData.color)
          ) {
            throw new Error("Invalid main color hex code");
          }
        }

        if (plainProductData.availableColors?.length > 0) {
          plainProductData.availableColors =
            plainProductData.availableColors.filter(
              (color) =>
                color.name &&
                color.hexCode &&
                /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color.hexCode)
            );
        }

        // Handle category
        if (
          typeof plainProductData.category === "string" &&
          !plainProductData.category.match(/^[0-9a-fA-F]{24}$/)
        ) {
          const suggestedCategory = await this.suggestNewCategory(
            plainProductData.category
          );
          plainProductData.category = suggestedCategory._id;
        }

        // Handle unit
        if (
          plainProductData.unit &&
          typeof plainProductData.unit === "object"
        ) {
          plainProductData.unit = this.formatUnitData(plainProductData.unit);
        }

        // Log the final data being sent
        console.log("Final data being sent to API:", {
          ...plainProductData,
          images: plainProductData.images,
        });

        const response = await apiClient.post(
          `/products/${userId}/products`,
          plainProductData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        // Validate the response
        if (!response.data) {
          throw new Error("No data received from the server");
        }

        // Ensure the response contains the images
        if (!response.data.images || !Array.isArray(response.data.images)) {
          console.warn("API response missing images array:", response.data);
          // Add the images to the response data if they're missing
          response.data.images = plainProductData.images;
        } else {
          console.log("API response images:", response.data.images);
        }

        // Update the local state
        this.products.push(response.data);
        toast.success("Product created successfully");

        return response.data;
      } catch (error) {
        console.error("Error details:", {
          message: error.message,
          response: error.response?.data,
          request: error.request,
          config: error.config,
        });
        // Improved error handling
        const errorMessage =
          error.response?.data?.error ||
          error.message ||
          "Error creating product";
        toast.error(errorMessage);
        throw error;
      }
    },

    async createCategory(categoryData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/categories", categoryData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        console.log("Created category:", response.data);

        // Update the local categories state
        if (this.categories) {
          this.categories = this.buildCategoryTree([
            ...this.categories,
            response.data,
          ]);
        } else {
          this.categories = [response.data];
        }

        return response.data;
      } catch (error) {
        console.error("Error creating category:", error);
        throw error;
      }
    },

    // Update updateProduct to handle color validation
    async updateProduct(productId, productData) {
      try {
        const userStore = useUserStore();
        const userId = userStore.user._id;
        const token = userStore.token;

        if (!token) {
          throw new Error("No token available");
        }

        const updatedProductData = { ...productData };

        // Color validation
        if (
          updatedProductData.color &&
          typeof updatedProductData.color === "string"
        ) {
          if (
            !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(updatedProductData.color)
          ) {
            throw new Error("Invalid main color hex code");
          }
        }

        if (updatedProductData.availableColors) {
          if (typeof updatedProductData.availableColors === "string") {
            updatedProductData.availableColors = JSON.parse(
              updatedProductData.availableColors
            );
          }
          updatedProductData.availableColors =
            updatedProductData.availableColors.filter(
              (color) =>
                color.name &&
                color.hexCode &&
                /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color.hexCode)
            );
        }

        // Validate variant colors
        if (updatedProductData.variants) {
          updatedProductData.variants.forEach((variant) => {
            if (
              variant.color &&
              (!variant.color.name || !variant.color.hexCode)
            ) {
              throw new Error(
                "All variant colors must have both name and color code"
              );
            }
            if (
              variant.color &&
              !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(variant.color.hexCode)
            ) {
              throw new Error(
                `Invalid hex code for variant color: ${variant.color.name}`
              );
            }
          });
        }

        // Handle unit
        if (
          updatedProductData.unit &&
          typeof updatedProductData.unit === "object"
        ) {
          updatedProductData.unit = this.formatUnitData(
            updatedProductData.unit
          );
        }

        // Truncate metaTitle if it's too long
        if (
          updatedProductData.metaTitle &&
          updatedProductData.metaTitle.length > 60
        ) {
          updatedProductData.metaTitle = updatedProductData.metaTitle.substring(
            0,
            60
          );
          console.warn("MetaTitle was truncated to 60 characters");
        }

        const response = await apiClient.put(
          `/products/${userId}/products/${productId}`,
          updatedProductData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        const index = this.products.findIndex(
          (product) => product._id === productId
        );
        if (index !== -1) {
          this.products[index] = response.data;
        } else {
          this.products.push(response.data);
        }
        return response.data;
      } catch (error) {
        console.error("Error creating product:", {
          message: error.message,
          response: error.response?.data,
          status: error.response?.status,
          config: error.config,
        });
        this.handleProductError(error, "Error updating product");
      }
    },

    // Add new methods for color management
    setColorFilter(color) {
      this.filters.color = color;
    },

    clearFilters() {
      this.filters = {
        unitCategory: null,
        unitRange: { min: null, max: null },
        color: null,
      };
    },

    // Add method to fetch products by color
    async searchProductsByColor(colorName) {
      try {
        return await this.fetchProductsWithFilters({ color: colorName });
      } catch (error) {
        console.error("Error searching products by color:", error);
        toast.error("Failed to search products by color");
        throw error;
      }
    },

    async addBulkProducts(productsData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/products/bulk", productsData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        this.products.push(...response.data);
        return response.data;
      } catch (error) {
        this.handleProductError(error, "Error adding bulk products");
      }
    },

    formatUnitData(unit) {
      return {
        base: String(unit.base),
        value: Number(unit.value),
        display: unit.display || `${unit.value}${unit.base}`,
        category: unit.category,
        baseUnit: unit.baseUnit,
        conversionFactor: Number(unit.conversionFactor),
        displayUnit: unit.displayUnit,
        packagingUnit: unit.packagingUnit,
        precision: Number(unit.precision),
        compoundUnit: unit.compoundUnit,
        regionSpecificDisplay: unit.regionSpecificDisplay,
      };
    },

    handleProductError(error, defaultMessage) {
      console.error(defaultMessage, error);
      if (error.response && error.response.data && error.response.data.error) {
        toast.error(error.response.data.error);
      } else {
        toast.error(defaultMessage);
      }
      throw error;
    },

    async deleteProduct(productId) {
      try {
        const userStore = useUserStore();
        if (!userStore || !userStore.user || !userStore.user._id) {
          throw new Error("User information is not available");
        }
        const userId = userStore.user._id;

        const url = `/products/${userId}/products/${productId}`;
        console.log("Delete URL:", url);

        const response = await apiClient.delete(url);
        console.log("Delete response:", response);

        this.products = this.products.filter(
          (product) => product._id !== productId
        );
        return response.data;
      } catch (error) {
        console.error("Error deleting product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        } else if (error.request) {
          console.error("No response received:", error.request);
        } else {
          console.error("Error message:", error.message);
        }
        console.error("Error config:", error.config);
        throw error;
      }
    },
  },
});
