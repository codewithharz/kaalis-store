// frontend/src/store/product.js
import { defineStore } from "pinia";
import apiClient from "../api/axios";
import axios from "axios";
import { useUserStore } from "./user";
import { toast } from "vue-sonner";
export const useProductStore = defineStore("product", {
  state: () => ({
    products: [],
    product: null,
    categories: [],
  }),
  getters: {
    flattenedCategories: (state) => {
      // Add a safety check
      if (!state.categories || state.categories.length === 0) {
        return [];
      }
      const flatten = (cats, prefix = "") =>
        cats.reduce((acc, cat) => {
          const newCat = { ...cat, name: prefix + cat.name };
          return acc.concat(
            newCat,
            flatten(cat.children || [], prefix + "-- ")
          );
        }, []);
      return flatten(state.categories);
    },
  },
  actions: {
    async fetchProducts() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await axios.get("/products", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
      } catch (error) {
        console.error("Error fetching products:", error);
        this.products = []; // Ensure it's an empty array if fetch fails
      }
    },
    async fetchProductById(id) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${id}`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (
          typeof response.data === "string" &&
          response.data.includes("<!doctype html>")
        ) {
          console.error("Received HTML instead of JSON:", response.data);
          throw new Error("Invalid response format");
        }

        console.log("Fetched product:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        throw error;
      }
    },

    async fetchCategories() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/categories", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.categories = this.buildCategoryTree(response.data);
        return this.categories;
      } catch (error) {
        console.error("Error fetching categories:", error);
        this.categories = []; // Ensure categories is an empty array if fetch fails
        throw error;
      }
    },

    async fetchRelatedProducts(productId, limit = 4) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${productId}/related`, {
          params: { limit },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        return response.data.relatedProducts;
      } catch (error) {
        console.error("Error fetching related products:", error);
        toast.error("Failed to load related products");
        return [];
      }
    },

    async rateProduct(productId, rating, review) {
      try {
        const userStore = useUserStore();
        const response = await apiClient.post(
          `/products/${productId}/rate`,
          { rating, review },
          {
            headers: {
              Authorization: `Bearer ${userStore.token}`,
            },
          }
        );

        // Update the product in the local state if it exists
        const productIndex = this.products.findIndex(
          (p) => p._id === productId
        );
        if (productIndex !== -1) {
          this.products[productIndex] = {
            ...this.products[productIndex],
            ...response.data.product,
          };
        }

        toast.success("Product rated successfully");
        return response.data;
      } catch (error) {
        console.error("Error rating product:", error);
        toast.error("Failed to rate product");
        throw error;
      }
    },

    async fetchProductReviews(productId) {
      try {
        const response = await apiClient.get(`/products/${productId}/ratings`);
        return response.data;
      } catch (error) {
        console.error("Error fetching product reviews:", error);
        toast.error("Failed to load product reviews");
        throw error;
      }
    },

    async fetchRandomProducts(limit = 4, excludeId = null) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: {
            random: true,
            limit,
            excludeId,
          },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        return response.data;
      } catch (error) {
        console.error("Error fetching random products:", error);
        toast.error("Failed to load random products");
        return [];
      }
    },

    // async fetchProductsByCategory(categoryId) {
    //   try {
    //     const userStore = useUserStore();
    //     const token = userStore.token || localStorage.getItem("token");
    //     const response = await apiClient.get(
    //       `/products/category/${categoryId}`,
    //       {
    //         headers: {
    //           Authorization: `Bearer ${token}`,
    //         },
    //       }
    //     );
    //     return response.data;
    //   } catch (error) {
    //     console.error("Error fetching products by category:", error);
    //     throw error;
    //   }
    // },

    async fetchProductsByCategory(categorySlug) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        console.log(`Fetching products for category slug: ${categorySlug}`);
        const response = await apiClient.get(
          `/categories/slug/${categorySlug}/products`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        console.log("API response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching products by category:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
        }
        throw error;
      }
    },

    buildCategoryTree(categories) {
      const categoryMap = {};
      const rootCategories = [];

      // First pass: create a map of categories
      categories.forEach((category) => {
        categoryMap[category._id] = { ...category, children: [] };
      });

      // Second pass: build the tree structure
      categories.forEach((category) => {
        if (category.parent) {
          const parent = categoryMap[category.parent];
          if (parent) {
            parent.children.push(categoryMap[category._id]);
          }
        } else {
          rootCategories.push(categoryMap[category._id]);
        }
      });

      return rootCategories;
    },
    async suggestNewCategory(categoryName) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post(
          "/categories/suggest",
          { name: categoryName },
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("Suggested new category:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error suggesting new category:", error);
        throw error;
      }
    },
    async createProduct(productData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const userId = userStore.user._id;

        // Convert the reactive object to a plain JavaScript object
        const plainProductData = JSON.parse(JSON.stringify(productData));

        // Handle the category field
        if (
          typeof plainProductData.category === "string" &&
          !plainProductData.category.match(/^[0-9a-fA-F]{24}$/)
        ) {
          // If category is a string and not a valid ObjectId, it's a new category name
          console.log("New category name detected:", plainProductData.category);

          // Suggest a new category
          const suggestedCategory = await this.suggestNewCategory(
            plainProductData.category
          );
          plainProductData.category = suggestedCategory._id;

          // Create a new category
          const newCategory = await this.createCategory({
            name: plainProductData.category,
          });

          plainProductData.category = newCategory._id;
        } else {
          console.log(
            "Existing category ID detected:",
            plainProductData.category
          );
        }

        console.log("Creating product with data:", plainProductData);

        const response = await apiClient.post(
          `/products/${userId}/products`,
          plainProductData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("API response:", response.data);

        this.products.push(response.data);
        return response.data;
      } catch (error) {
        console.error("Error creating product:", error);
        throw error;
      }
    },

    async createCategory(categoryData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/categories", categoryData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        console.log("Created category:", response.data);

        // Update the local categories state
        if (this.categories) {
          this.categories = this.buildCategoryTree([
            ...this.categories,
            response.data,
          ]);
        } else {
          this.categories = [response.data];
        }

        return response.data;
      } catch (error) {
        console.error("Error creating category:", error);
        throw error;
      }
    },

    async updateProduct(productId, productData) {
      const userStore = useUserStore();
      const userId = userStore.user._id;
      const token = userStore.token;

      try {
        if (!token) {
          throw new Error("No token available");
        }

        const response = await apiClient.put(
          `/products/${userId}/products/${productId}`,
          productData,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        console.log("Updated product:", response.data);

        // Ensure this.products is an array before using findIndex
        if (!Array.isArray(this.products)) {
          console.warn("Products is not an array. Initializing it.");
          this.products = [];
        }

        // Update the product in the local state
        const index = this.products.findIndex(
          (product) => product._id === productId
        );
        if (index !== -1) {
          this.products[index] = response.data;
        } else {
          // If the product wasn't in the list, add it
          this.products.push(response.data);
          console.warn(
            `Product with id ${productId} not found in local state. Adding it.`
          );
        }
        return response.data;
      } catch (error) {
        console.error("Error updating product:", error);
        throw error;
      }
    },

    async deleteProduct(productId) {
      try {
        const userStore = useUserStore();
        if (!userStore || !userStore.user || !userStore.user._id) {
          throw new Error("User information is not available");
        }
        const userId = userStore.user._id;

        const url = `/products/${userId}/products/${productId}`;
        console.log("Delete URL:", url);

        const response = await apiClient.delete(url);
        console.log("Delete response:", response);

        this.products = this.products.filter(
          (product) => product._id !== productId
        );
        return response.data;
      } catch (error) {
        console.error("Error deleting product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        } else if (error.request) {
          console.error("No response received:", error.request);
        } else {
          console.error("Error message:", error.message);
        }
        console.error("Error config:", error.config);
        throw error;
      }
    },
  },
});



===============================================version-2============================================
// frontend/src/store/product.js
import { defineStore } from "pinia";
import apiClient from "../api/axios";
import axios from "axios";
import { useUserStore } from "./user";
import { toast } from "vue-sonner";
export const useProductStore = defineStore("product", {
  state: () => ({
    products: [],
    product: null,
    categories: [],
    filters: {
      unitCategory: null,
      unitRange: { min: null, max: null },
    },
  }),
  getters: {
    flattenedCategories: (state) => {
      // Add a safety check
      if (!state.categories || state.categories.length === 0) {
        return [];
      }
      const flatten = (cats, prefix = "") =>
        cats.reduce((acc, cat) => {
          const newCat = { ...cat, name: prefix + cat.name };
          return acc.concat(
            newCat,
            flatten(cat.children || [], prefix + "-- ")
          );
        }, []);
      return flatten(state.categories);
    },
  },
  actions: {
    async fetchProducts() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await axios.get("/products", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
      } catch (error) {
        console.error("Error fetching products:", error);
        this.products = []; // Ensure it's an empty array if fetch fails
      }
    },

    async fetchProductById(id) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${id}`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (
          typeof response.data === "string" &&
          response.data.includes("<!doctype html>")
        ) {
          console.error("Received HTML instead of JSON:", response.data);
          throw new Error("Invalid response format");
        }

        console.log("Fetched product:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        throw error;
      }
    },

    async fetchCategories() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/categories", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.categories = this.buildCategoryTree(response.data);
        return this.categories;
      } catch (error) {
        console.error("Error fetching categories:", error);
        this.categories = []; // Ensure categories is an empty array if fetch fails
        throw error;
      }
    },

    async fetchRelatedProducts(productId, limit = 4) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${productId}/related`, {
          params: { limit },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        return response.data.relatedProducts;
      } catch (error) {
        console.error("Error fetching related products:", error);
        toast.error("Failed to load related products");
        return [];
      }
    },

    async fetchProductsWithFilters(filters) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: filters,
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
        return response.data;
      } catch (error) {
        console.error("Error fetching products with filters:", error);
        this.products = [];
        throw error;
      }
    },

    async rateProduct(productId, rating, review) {
      try {
        const userStore = useUserStore();
        const response = await apiClient.post(
          `/products/${productId}/rate`,
          { rating, review },
          {
            headers: {
              Authorization: `Bearer ${userStore.token}`,
            },
          }
        );

        // Update the product in the local state if it exists
        const productIndex = this.products.findIndex(
          (p) => p._id === productId
        );
        if (productIndex !== -1) {
          this.products[productIndex] = {
            ...this.products[productIndex],
            ...response.data.product,
          };
        }

        toast.success("Product rated successfully");
        return response.data;
      } catch (error) {
        console.error("Error rating product:", error);
        toast.error("Failed to rate product");
        throw error;
      }
    },

    async fetchProductReviews(productId) {
      try {
        const response = await apiClient.get(`/products/${productId}/ratings`);
        return response.data;
      } catch (error) {
        console.error("Error fetching product reviews:", error);
        toast.error("Failed to load product reviews");
        throw error;
      }
    },

    async fetchRandomProducts(limit = 4, excludeId = null) {
      try {
        console.log(
          "Fetching random products with limit:",
          limit,
          "excludeId:",
          excludeId
        );
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: {
            random: true,
            limit,
            excludeId,
          },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        console.log("Received response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching random products:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        toast.error("Failed to load random products");
        return [];
      }
    },

    async fetchProductsByCategory(categorySlug) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        console.log(`Fetching products for category slug: ${categorySlug}`);
        const response = await apiClient.get(
          `/categories/slug/${categorySlug}/products`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        console.log("API response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching products by category:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
        }
        throw error;
      }
    },

    buildCategoryTree(categories) {
      const categoryMap = {};
      const rootCategories = [];

      // First pass: create a map of categories
      categories.forEach((category) => {
        categoryMap[category._id] = { ...category, children: [] };
      });

      // Second pass: build the tree structure
      categories.forEach((category) => {
        if (category.parent) {
          const parent = categoryMap[category.parent];
          if (parent) {
            parent.children.push(categoryMap[category._id]);
          }
        } else {
          rootCategories.push(categoryMap[category._id]);
        }
      });

      return rootCategories;
    },
    async suggestNewCategory(categoryName) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post(
          "/categories/suggest",
          { name: categoryName },
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("Suggested new category:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error suggesting new category:", error);
        throw error;
      }
    },

    async createProduct(productData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const userId = userStore.user._id;

        // Convert the reactive object to a plain JavaScript object
        const plainProductData = JSON.parse(JSON.stringify(productData));

        // Handle the category field
        if (
          typeof plainProductData.category === "string" &&
          !plainProductData.category.match(/^[0-9a-fA-F]{24}$/)
        ) {
          console.log("New category name detected:", plainProductData.category);
          const suggestedCategory = await this.suggestNewCategory(
            plainProductData.category
          );
          plainProductData.category = suggestedCategory._id;
        } else {
          console.log(
            "Existing category ID detected:",
            plainProductData.category
          );
        }

        // Ensure unit data is correctly formatted
        if (
          plainProductData.unit &&
          typeof plainProductData.unit === "object"
        ) {
          if (plainProductData.unit.base && plainProductData.unit.base.base) {
            // If unit is nested, flatten it
            plainProductData.unit = {
              base: String(plainProductData.unit.base.base),
              value: Number(plainProductData.unit.base.value),
              display:
                plainProductData.unit.base.display ||
                `${plainProductData.unit.base.value}${plainProductData.unit.base.base}`,
            };
          } else {
            // If unit is not nested, ensure correct types
            plainProductData.unit = {
              base: String(plainProductData.unit.base),
              value: Number(plainProductData.unit.value),
              display:
                plainProductData.unit.display ||
                `${plainProductData.unit.value}${plainProductData.unit.base}`,
            };
          }
        }

        console.log("Creating product with data:", plainProductData);
        console.log("Unit object being sent:", plainProductData.unit);

        const response = await apiClient.post(
          `/products/${userId}/products`,
          plainProductData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("API response:", response.data);

        this.products.push(response.data);
        return response.data;
      } catch (error) {
        console.error("Error creating product:", error);
        throw error;
      }
    },

    async createCategory(categoryData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/categories", categoryData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        console.log("Created category:", response.data);

        // Update the local categories state
        if (this.categories) {
          this.categories = this.buildCategoryTree([
            ...this.categories,
            response.data,
          ]);
        } else {
          this.categories = [response.data];
        }

        return response.data;
      } catch (error) {
        console.error("Error creating category:", error);
        throw error;
      }
    },

    async updateProduct(productId, productData) {
      const userStore = useUserStore();
      const userId = userStore.user._id;
      const token = userStore.token;

      console.log("updateProduct called with:", { productId, productData });

      // const url = `${apiClient.defaults.baseURL}/products/${userId}/products/${productId}`;
      // console.log("Full update URL:", url);

      try {
        if (!token) {
          throw new Error("No token available");
        }

        // Ensure unit.base is a string
        if (productData.unit && productData.unit.base) {
          productData.unit.base = String(productData.unit.base);
        }

        // Make sure productId is defined and valid
        if (!productId) {
          throw new Error("Product ID is required for update");
        }

        // Ensure brand is included in the request
        const updatedProductData = {
          ...productData,
          brand: productData.brand || "", // Include brand, default to empty string if not provided
        };

        const response = await apiClient.put(
          `/products/${userId}/products/${productId}`,
          productData,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        console.log("Updated product:", response.data);

        // Ensure this.products is an array before using findIndex
        if (!Array.isArray(this.products)) {
          console.warn("Products is not an array. Initializing it.");
          this.products = [];
        }

        // Update the product in the local state
        const index = this.products.findIndex(
          (product) => product._id === productId
        );
        if (index !== -1) {
          this.products[index] = response.data;
        } else {
          // If the product wasn't in the list, add it
          this.products.push(response.data);
          console.warn(
            `Product with id ${productId} not found in local state. Adding it.`
          );
        }
        return response.data;
      } catch (error) {
        console.error("Error updating product:", error);
        throw error;
      }
    },

    async deleteProduct(productId) {
      try {
        const userStore = useUserStore();
        if (!userStore || !userStore.user || !userStore.user._id) {
          throw new Error("User information is not available");
        }
        const userId = userStore.user._id;

        const url = `/products/${userId}/products/${productId}`;
        console.log("Delete URL:", url);

        const response = await apiClient.delete(url);
        console.log("Delete response:", response);

        this.products = this.products.filter(
          (product) => product._id !== productId
        );
        return response.data;
      } catch (error) {
        console.error("Error deleting product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        } else if (error.request) {
          console.error("No response received:", error.request);
        } else {
          console.error("Error message:", error.message);
        }
        console.error("Error config:", error.config);
        throw error;
      }
    },
  },
});


==========================version-2============================
// frontend/src/store/product.js
import { defineStore } from "pinia";
import apiClient from "../api/axios";
import axios from "axios";
import { useUserStore } from "./user";
import { toast } from "vue-sonner";
export const useProductStore = defineStore("product", {
  state: () => ({
    products: [],
    product: null,
    categories: [],
    filters: {
      unitCategory: null,
      unitRange: { min: null, max: null },
    },
  }),
  getters: {
    flattenedCategories: (state) => {
      // Add a safety check
      if (!state.categories || state.categories.length === 0) {
        return [];
      }
      const flatten = (cats, prefix = "") =>
        cats.reduce((acc, cat) => {
          const newCat = { ...cat, name: prefix + cat.name };
          return acc.concat(
            newCat,
            flatten(cat.children || [], prefix + "-- ")
          );
        }, []);
      return flatten(state.categories);
    },
  },
  actions: {
    async fetchProducts() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await axios.get("/products", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
      } catch (error) {
        console.error("Error fetching products:", error);
        this.products = []; // Ensure it's an empty array if fetch fails
      }
    },

    async fetchProductById(id) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${id}`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (
          typeof response.data === "string" &&
          response.data.includes("<!doctype html>")
        ) {
          console.error("Received HTML instead of JSON:", response.data);
          throw new Error("Invalid response format");
        }

        console.log("Fetched product:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        throw error;
      }
    },

    async fetchCategories() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/categories", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.categories = this.buildCategoryTree(response.data);
        return this.categories;
      } catch (error) {
        console.error("Error fetching categories:", error);
        this.categories = []; // Ensure categories is an empty array if fetch fails
        throw error;
      }
    },

    async fetchRelatedProducts(productId, limit = 4) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${productId}/related`, {
          params: { limit },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        return response.data.relatedProducts;
      } catch (error) {
        console.error("Error fetching related products:", error);
        toast.error("Failed to load related products");
        return [];
      }
    },

    async fetchProductsWithFilters(filters) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: filters,
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
        return response.data;
      } catch (error) {
        console.error("Error fetching products with filters:", error);
        this.products = [];
        throw error;
      }
    },

    async rateProduct(productId, rating, review) {
      try {
        const userStore = useUserStore();
        const response = await apiClient.post(
          `/products/${productId}/rate`,
          { rating, review },
          {
            headers: {
              Authorization: `Bearer ${userStore.token}`,
            },
          }
        );

        // Update the product in the local state if it exists
        const productIndex = this.products.findIndex(
          (p) => p._id === productId
        );
        if (productIndex !== -1) {
          this.products[productIndex] = {
            ...this.products[productIndex],
            ...response.data.product,
          };
        }

        toast.success("Product rated successfully");
        return response.data;
      } catch (error) {
        console.error("Error rating product:", error);
        toast.error("Failed to rate product");
        throw error;
      }
    },

    async fetchProductReviews(productId) {
      try {
        const response = await apiClient.get(`/products/${productId}/ratings`);
        return response.data;
      } catch (error) {
        console.error("Error fetching product reviews:", error);
        toast.error("Failed to load product reviews");
        throw error;
      }
    },

    async fetchRandomProducts(limit = 4, excludeId = null) {
      try {
        console.log(
          "Fetching random products with limit:",
          limit,
          "excludeId:",
          excludeId
        );
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: {
            random: true,
            limit,
            excludeId,
          },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        console.log("Received response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching random products:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        toast.error("Failed to load random products");
        return [];
      }
    },

    async fetchProductsByCategory(categorySlug) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        console.log(`Fetching products for category slug: ${categorySlug}`);
        const response = await apiClient.get(
          `/categories/slug/${categorySlug}/products`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        console.log("API response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching products by category:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
        }
        throw error;
      }
    },

    buildCategoryTree(categories) {
      const categoryMap = {};
      const rootCategories = [];

      // First pass: create a map of categories
      categories.forEach((category) => {
        categoryMap[category._id] = { ...category, children: [] };
      });

      // Second pass: build the tree structure
      categories.forEach((category) => {
        if (category.parent) {
          const parent = categoryMap[category.parent];
          if (parent) {
            parent.children.push(categoryMap[category._id]);
          }
        } else {
          rootCategories.push(categoryMap[category._id]);
        }
      });

      return rootCategories;
    },
    async suggestNewCategory(categoryName) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post(
          "/categories/suggest",
          { name: categoryName },
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("Suggested new category:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error suggesting new category:", error);
        throw error;
      }
    },

    async createProduct(productData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const userId = userStore.user._id;

        // Convert the reactive object to a plain JavaScript object
        const plainProductData = JSON.parse(JSON.stringify(productData));

        // Handle the category field
        if (
          typeof plainProductData.category === "string" &&
          !plainProductData.category.match(/^[0-9a-fA-F]{24}$/)
        ) {
          console.log("New category name detected:", plainProductData.category);
          const suggestedCategory = await this.suggestNewCategory(
            plainProductData.category
          );
          plainProductData.category = suggestedCategory._id;
        } else {
          console.log(
            "Existing category ID detected:",
            plainProductData.category
          );
        }

        // Ensure unit data is correctly formatted
        if (
          plainProductData.unit &&
          typeof plainProductData.unit === "object"
        ) {
          if (plainProductData.unit.base && plainProductData.unit.base.base) {
            // If unit is nested, flatten it
            plainProductData.unit = {
              base: String(plainProductData.unit.base.base),
              value: Number(plainProductData.unit.base.value),
              display:
                plainProductData.unit.base.display ||
                `${plainProductData.unit.base.value}${plainProductData.unit.base.base}`,
            };
          } else {
            // If unit is not nested, ensure correct types
            plainProductData.unit = {
              base: String(plainProductData.unit.base),
              value: Number(plainProductData.unit.value),
              display:
                plainProductData.unit.display ||
                `${plainProductData.unit.value}${plainProductData.unit.base}`,
            };
          }
        }

        console.log("Creating product with data:", plainProductData);
        console.log("Unit object being sent:", plainProductData.unit);

        const response = await apiClient.post(
          `/products/${userId}/products`,
          plainProductData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("API response:", response.data);

        this.products.push(response.data);
        return response.data;
      } catch (error) {
        console.error("Error creating product:", error);
        throw error;
      }
    },

    async createCategory(categoryData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/categories", categoryData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        console.log("Created category:", response.data);

        // Update the local categories state
        if (this.categories) {
          this.categories = this.buildCategoryTree([
            ...this.categories,
            response.data,
          ]);
        } else {
          this.categories = [response.data];
        }

        return response.data;
      } catch (error) {
        console.error("Error creating category:", error);
        throw error;
      }
    },

    async updateProduct(productId, productData) {
      const userStore = useUserStore();
      const userId = userStore.user._id;
      const token = userStore.token;

      console.log("updateProduct called with:", { productId, productData });

      // const url = `${apiClient.defaults.baseURL}/products/${userId}/products/${productId}`;
      // console.log("Full update URL:", url);

      try {
        if (!token) {
          throw new Error("No token available");
        }

        // Ensure unit.base is a string
        if (productData.unit && productData.unit.base) {
          productData.unit.base = String(productData.unit.base);
        }

        // Make sure productId is defined and valid
        if (!productId) {
          throw new Error("Product ID is required for update");
        }

        // Ensure brand is included in the request
        const updatedProductData = {
          ...productData,
          brand: productData.brand || "", // Include brand, default to empty string if not provided
        };

        const response = await apiClient.put(
          `/products/${userId}/products/${productId}`,
          productData,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        console.log("Updated product:", response.data);

        // Ensure this.products is an array before using findIndex
        if (!Array.isArray(this.products)) {
          console.warn("Products is not an array. Initializing it.");
          this.products = [];
        }

        // Update the product in the local state
        const index = this.products.findIndex(
          (product) => product._id === productId
        );
        if (index !== -1) {
          this.products[index] = response.data;
        } else {
          // If the product wasn't in the list, add it
          this.products.push(response.data);
          console.warn(
            `Product with id ${productId} not found in local state. Adding it.`
          );
        }
        return response.data;
      } catch (error) {
        console.error("Error updating product:", error);
        throw error;
      }
    },

    async deleteProduct(productId) {
      try {
        const userStore = useUserStore();
        if (!userStore || !userStore.user || !userStore.user._id) {
          throw new Error("User information is not available");
        }
        const userId = userStore.user._id;

        const url = `/products/${userId}/products/${productId}`;
        console.log("Delete URL:", url);

        const response = await apiClient.delete(url);
        console.log("Delete response:", response);

        this.products = this.products.filter(
          (product) => product._id !== productId
        );
        return response.data;
      } catch (error) {
        console.error("Error deleting product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        } else if (error.request) {
          console.error("No response received:", error.request);
        } else {
          console.error("Error message:", error.message);
        }
        console.error("Error config:", error.config);
        throw error;
      }
    },
  },
});



=========================================V-3=================================================
// frontend/src/store/product.js
import { defineStore } from "pinia";
import apiClient from "../api/axios";
import axios from "axios";
import { useUserStore } from "./user";
import { toast } from "vue-sonner";

export const useProductStore = defineStore("product", {
  state: () => ({
    products: [],
    product: null,
    shippingRules: null,
    categories: [],
    filters: {
      unitCategory: null,
      unitRange: { min: null, max: null },
    },
  }),

  getters: {
    flattenedCategories: (state) => {
      // Add a safety check
      if (!state.categories || state.categories.length === 0) {
        return [];
      }
      const flatten = (cats, prefix = "") =>
        cats.reduce((acc, cat) => {
          const newCat = { ...cat, name: prefix + cat.name };
          return acc.concat(
            newCat,
            flatten(cat.children || [], prefix + "-- ")
          );
        }, []);
      return flatten(state.categories);
    },
  },
  actions: {
    async fetchProducts() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await axios.get("/products", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
        this.shippingRules = response.data.shippingRules;
      } catch (error) {
        console.error("Error fetching products:", error);
        this.products = []; // Ensure it's an empty array if fetch fails
        this.shippingRules = null;
      }
    },

    async fetchProductById(id) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${id}`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (
          typeof response.data === "string" &&
          response.data.includes("<!doctype html>")
        ) {
          console.error("Received HTML instead of JSON:", response.data);
          throw new Error("Invalid response format");
        }

        console.log("Fetched product:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        throw error;
      }
    },

    async fetchCategories() {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/categories", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.categories = this.buildCategoryTree(response.data);
        return this.categories;
      } catch (error) {
        console.error("Error fetching categories:", error);
        this.categories = []; // Ensure categories is an empty array if fetch fails
        throw error;
      }
    },

    async fetchRelatedProducts(productId, limit = 4) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get(`/products/${productId}/related`, {
          params: { limit },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        return response.data.relatedProducts;
      } catch (error) {
        console.error("Error fetching related products:", error);
        toast.error("Failed to load related products");
        return [];
      }
    },

    async fetchProductsWithFilters(filters) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: filters,
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        this.products = response.data;
        return response.data;
      } catch (error) {
        console.error("Error fetching products with filters:", error);
        this.products = [];
        throw error;
      }
    },

    async rateProduct(productId, rating, review) {
      try {
        const userStore = useUserStore();
        const response = await apiClient.post(
          `/products/${productId}/rate`,
          { rating, review },
          {
            headers: {
              Authorization: `Bearer ${userStore.token}`,
            },
          }
        );

        // Update the product in the local state if it exists
        const productIndex = this.products.findIndex(
          (p) => p._id === productId
        );
        if (productIndex !== -1) {
          this.products[productIndex] = {
            ...this.products[productIndex],
            ...response.data.product,
          };
        }

        toast.success("Product rated successfully");
        return response.data;
      } catch (error) {
        console.error("Error rating product:", error);
        toast.error("Failed to rate product");
        throw error;
      }
    },

    async fetchProductReviews(productId) {
      try {
        const response = await apiClient.get(`/products/${productId}/ratings`);
        return response.data;
      } catch (error) {
        console.error("Error fetching product reviews:", error);
        toast.error("Failed to load product reviews");
        throw error;
      }
    },

    async fetchRandomProducts(limit = 4, excludeId = null) {
      try {
        console.log(
          "Fetching random products with limit:",
          limit,
          "excludeId:",
          excludeId
        );
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const response = await apiClient.get("/products", {
          params: {
            random: true,
            limit,
            excludeId,
          },
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });
        console.log("Received response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching random products:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        }
        toast.error("Failed to load random products");
        return [];
      }
    },

    async fetchProductsByCategory(categorySlug) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        console.log(`Fetching products for category slug: ${categorySlug}`);
        const response = await apiClient.get(
          `/categories/slug/${categorySlug}/products`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        console.log("API response:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error fetching products by category:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
        }
        throw error;
      }
    },

    buildCategoryTree(categories) {
      const categoryMap = {};
      const rootCategories = [];

      // First pass: create a map of categories
      categories.forEach((category) => {
        categoryMap[category._id] = { ...category, children: [] };
      });

      // Second pass: build the tree structure
      categories.forEach((category) => {
        if (category.parent) {
          const parent = categoryMap[category.parent];
          if (parent) {
            parent.children.push(categoryMap[category._id]);
          }
        } else {
          rootCategories.push(categoryMap[category._id]);
        }
      });

      return rootCategories;
    },
    async suggestNewCategory(categoryName) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post(
          "/categories/suggest",
          { name: categoryName },
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        console.log("Suggested new category:", response.data);
        return response.data;
      } catch (error) {
        console.error("Error suggesting new category:", error);
        throw error;
      }
    },

    async createProduct(productData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");
        const userId = userStore.user._id;

        const plainProductData = JSON.parse(JSON.stringify(productData));

        // Handle category
        if (
          typeof plainProductData.category === "string" &&
          !plainProductData.category.match(/^[0-9a-fA-F]{24}$/)
        ) {
          const suggestedCategory = await this.suggestNewCategory(
            plainProductData.category
          );
          plainProductData.category = suggestedCategory._id;
        }

        // Handle unit
        if (
          plainProductData.unit &&
          typeof plainProductData.unit === "object"
        ) {
          plainProductData.unit = this.formatUnitData(plainProductData.unit);
        }

        // Truncate metaTitle if it's too long
        if (
          plainProductData.metaTitle &&
          plainProductData.metaTitle.length > 60
        ) {
          plainProductData.metaTitle = plainProductData.metaTitle.substring(
            0,
            60
          );
          console.warn("MetaTitle was truncated to 60 characters");
        }

        const response = await apiClient.post(
          `/products/${userId}/products`,
          plainProductData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        this.products.push(response.data);
        return response.data;
      } catch (error) {
        this.handleProductError(error, "Error creating product");
      }
    },

    async createCategory(categoryData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/categories", categoryData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        console.log("Created category:", response.data);

        // Update the local categories state
        if (this.categories) {
          this.categories = this.buildCategoryTree([
            ...this.categories,
            response.data,
          ]);
        } else {
          this.categories = [response.data];
        }

        return response.data;
      } catch (error) {
        console.error("Error creating category:", error);
        throw error;
      }
    },

    async updateProduct(productId, productData) {
      try {
        const userStore = useUserStore();
        const userId = userStore.user._id;
        const token = userStore.token;

        if (!token) {
          throw new Error("No token available");
        }

        const updatedProductData = { ...productData };

        // Handle unit
        if (
          updatedProductData.unit &&
          typeof updatedProductData.unit === "object"
        ) {
          updatedProductData.unit = this.formatUnitData(
            updatedProductData.unit
          );
        }

        // Truncate metaTitle if it's too long
        if (
          updatedProductData.metaTitle &&
          updatedProductData.metaTitle.length > 60
        ) {
          updatedProductData.metaTitle = updatedProductData.metaTitle.substring(
            0,
            60
          );
          console.warn("MetaTitle was truncated to 60 characters");
        }

        const response = await apiClient.put(
          `/products/${userId}/products/${productId}`,
          updatedProductData,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        const index = this.products.findIndex(
          (product) => product._id === productId
        );
        if (index !== -1) {
          this.products[index] = response.data;
        } else {
          this.products.push(response.data);
        }
        return response.data;
      } catch (error) {
        this.handleProductError(error, "Error updating product");
      }
    },

    async addBulkProducts(productsData) {
      try {
        const userStore = useUserStore();
        const token = userStore.token || localStorage.getItem("token");

        const response = await apiClient.post("/products/bulk", productsData, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        this.products.push(...response.data);
        return response.data;
      } catch (error) {
        this.handleProductError(error, "Error adding bulk products");
      }
    },

    formatUnitData(unit) {
      return {
        base: String(unit.base),
        value: Number(unit.value),
        display: unit.display || `${unit.value}${unit.base}`,
        category: unit.category,
        baseUnit: unit.baseUnit,
        conversionFactor: Number(unit.conversionFactor),
        displayUnit: unit.displayUnit,
        packagingUnit: unit.packagingUnit,
        precision: Number(unit.precision),
        compoundUnit: unit.compoundUnit,
        regionSpecificDisplay: unit.regionSpecificDisplay,
      };
    },

    handleProductError(error, defaultMessage) {
      console.error(defaultMessage, error);
      if (error.response && error.response.data && error.response.data.error) {
        toast.error(error.response.data.error);
      } else {
        toast.error(defaultMessage);
      }
      throw error;
    },

    async deleteProduct(productId) {
      try {
        const userStore = useUserStore();
        if (!userStore || !userStore.user || !userStore.user._id) {
          throw new Error("User information is not available");
        }
        const userId = userStore.user._id;

        const url = `/products/${userId}/products/${productId}`;
        console.log("Delete URL:", url);

        const response = await apiClient.delete(url);
        console.log("Delete response:", response);

        this.products = this.products.filter(
          (product) => product._id !== productId
        );
        return response.data;
      } catch (error) {
        console.error("Error deleting product:", error);
        if (error.response) {
          console.error("Response data:", error.response.data);
          console.error("Response status:", error.response.status);
          console.error("Response headers:", error.response.headers);
        } else if (error.request) {
          console.error("No response received:", error.request);
        } else {
          console.error("Error message:", error.message);
        }
        console.error("Error config:", error.config);
        throw error;
      }
    },
  },
});
