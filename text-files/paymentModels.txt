const mongoose = require("mongoose");

// Create a sub-schema for payment items
const paymentItemSchema = new mongoose.Schema(
  {
    productId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      required: true,
    },
    quantity: {
      type: Number,
      required: true,
      min: 1,
    },
    price: {
      type: Number,
      required: true,
      min: 0,
    },
    vendorId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    vendorAmount: {
      type: Number,
      required: true,
      min: 0,
    },
    platformFee: {
      type: Number,
      required: true,
      min: 0,
    },
  },
  { _id: false }
);

// Shipping details schema
const shippingDetailsSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    firstName: {
      type: String,
      required: true,
      trim: true,
    },
    lastName: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    phone: {
      type: String,
      required: true,
      trim: true,
    },
    houseNo: String,
    street: String,
    city: String,
    state: String,
    country: String,
    postalCode: String,
    place: String,
    isDefault: {
      type: Boolean,
      default: false,
    },
  },
  {
    _id: false,
    timestamps: false,
  }
);

// bank details schema
const bankDetailsSchema = new mongoose.Schema(
  {
    accountName: {
      type: String,
      required: true,
      trim: true,
    },
    accountNumber: {
      type: String,
      required: true,
      trim: true,
    },
    bankCode: {
      type: String,
      required: true,
    },
    bankName: {
      type: String,
      required: true,
      trim: true,
    },
    recipientCode: String,
    lastVerified: Date,
  },
  { _id: false }
);
// Main payment schema
const paymentSchema = new mongoose.Schema(
  {
    orderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      required: true,
      index: true,
    },
    reference: {
      type: String,
      sparse: true, // Allow multiple null values
      index: true, // Create index but not unique
    },
    amount: {
      type: Number,
      required: true,
      min: 0,
      get: (v) => parseFloat(v.toFixed(2)),
      set: (v) => parseFloat(v.toFixed(2)),
    },
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    status: {
      type: String,
      enum: ["pending", "success", "failed"],
      default: "pending",
      index: true,
    },
    vendorAmount: {
      type: Number,
      required: true,
      min: 0,
      get: (v) => parseFloat(v.toFixed(2)),
      set: (v) => parseFloat(v.toFixed(2)),
    },
    platformFee: {
      type: Number,
      required: true,
      min: 0,
      get: (v) => parseFloat(v.toFixed(2)),
      set: (v) => parseFloat(v.toFixed(2)),
    },
    // NEW FIELD: Payout tracking fields
    payoutStatus: {
      type: String,
      enum: [
        "pending_payout",
        "payout_processing",
        "payout_completed",
        "payout_failed",
      ],
      default: "pending_payout",
      index: true, // Add index for payout queries
    },
    payoutScheduledDate: {
      type: Date,
      index: true, // Add index for scheduled payouts
    },
    payoutProcessedAt: Date,
    payoutReference: String,
    payoutRetries: {
      type: Number,
      default: 0,
    },
    payoutErrorMessage: String,
    paymentMethod: {
      type: String,
      enum: ["paystack", "bank_transfer", "cash"],
      required: true,
    },
    metadata: {
      userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        required: true,
        index: true,
      },
      userEmail: {
        type: String,
        required: true,
        trim: true,
        lowercase: true,
      },
      customerName: String,
      items: [paymentItemSchema],
      shipping: shippingDetailsSchema,
      custom_fields: [
        {
          display_name: String,
          variable_name: String,
          value: String,
        },
      ],
    },
    currency: {
      type: String,
      default: "NGN",
      uppercase: true,
    },
    bankDetails: bankDetailsSchema,
    refundDetails: {
      amount: Number,
      reason: String,
      status: String,
      processedAt: Date,
      processedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
      },
    },
    errorDetails: {
      code: String,
      message: String,
      timestamp: Date,
    },
    paystackData: Object,
    verificationData: Object,
  },
  {
    timestamps: true,
    toJSON: { getters: true, virtuals: true },
    toObject: { getters: true, virtuals: true },
  }
);

// NEW METHOD: Add payout-specific methods
paymentSchema.methods.scheduleVendorPayout = function (scheduledDate) {
  this.payoutStatus = "pending_payout";
  this.payoutScheduledDate =
    scheduledDate || new Date(Date.now() + 3 * 24 * 60 * 60 * 1000); // Default 3 days
  return this.save();
};

// NEW METHOD: Add payout processing methods
paymentSchema.methods.processVendorPayout = async function () {
  this.payoutStatus = "payout_processing";
  return this.save();
};

// NEW METHOD: Add payout completion methods
paymentSchema.methods.markPayoutComplete = async function (reference) {
  this.payoutStatus = "payout_completed";
  this.payoutProcessedAt = new Date();
  this.payoutReference = reference;
  return this.save();
};

// NEW METHOD: Add payout failure methods
paymentSchema.methods.markPayoutFailed = async function (error) {
  this.payoutStatus = "payout_failed";
  this.payoutRetries += 1;
  this.payoutErrorMessage = error.message;
  return this.save();
};

// NEW METHOD: Add static methods for payout queries
paymentSchema.statics.getPendingPayouts = function (vendorId) {
  return this.find({
    "metadata.items.vendorId": vendorId,
    status: "success",
    payoutStatus: "pending_payout",
    payoutScheduledDate: { $lte: new Date() },
  }).sort("payoutScheduledDate");
};

paymentSchema.statics.getVendorPayoutStats = async function (vendorId) {
  return this.aggregate([
    {
      $match: {
        "metadata.items.vendorId": vendorId,
        status: "success",
      },
    },
    {
      $group: {
        _id: "$payoutStatus",
        count: { $sum: 1 },
        totalAmount: { $sum: "$vendorAmount" },
      },
    },
  ]);
};

// Methods
paymentSchema.methods.validateShippingDetails = function () {
  const shipping = this.metadata.shipping;
  if (!shipping) return false;

  return ["firstName", "lastName", "email", "phone"].every(
    (field) => shipping[field] && shipping[field].toString().trim().length > 0
  );
};

paymentSchema.methods.markAsSuccessful = async function () {
  this.status = "success";
  return this.save();
};

paymentSchema.methods.markAsFailed = async function (error) {
  this.status = "failed";
  if (error) {
    this.errorDetails = {
      code: error.code || "PAYMENT_FAILED",
      message: error.message,
      timestamp: new Date(),
    };
  }
  return this.save();
};

// Static methods
paymentSchema.statics.findByReference = function (reference) {
  return this.findOne({ reference });
};

paymentSchema.statics.findByOrderId = function (orderId) {
  return this.findOne({ orderId });
};

paymentSchema.statics.getPaymentStats = async function (filter = {}) {
  return this.aggregate([
    { $match: filter },
    {
      $group: {
        _id: "$status",
        count: { $sum: 1 },
        totalAmount: { $sum: "$amount" },
      },
    },
  ]);
};

// Pre-save middleware
paymentSchema.pre("save", function (next) {
  try {
    // Basic validation
    if (this.vendorAmount + this.platformFee !== this.amount) {
      // next(new Error("Vendor amount plus platform fee must equal total amount"));
      // return;
      throw new Error(
        "Amount mismatch: vendor amount + platform fee must equal total amount"
      );
    }

    // Ensure reference exists for non-pending payments
    if (this.status !== "pending" && !this.reference) {
      throw new Error("Payment reference required for non-pending status");
    }

    // Validate required metadata
    if (!this.metadata || !this.metadata.userId || !this.metadata.userEmail) {
      throw new Error("Required metadata missing");
    }

    // Set reference if empty
    if (this.reference === "") {
      this.reference = null;
    }

    next();
  } catch (error) {
    next(error);
  }
});

// Create indexes without waiting
paymentSchema.set("autoIndex", false);

// Add indexes for frequent queries
paymentSchema.index({ "metadata.userId": 1, createdAt: -1 });
paymentSchema.index({ status: 1 });
paymentSchema.index({ reference: 1 });

// NEW INDEX: Add new indexes for payout queries
paymentSchema.index({
  "metadata.items.vendorId": 1,
  payoutStatus: 1,
  payoutScheduledDate: 1,
});
paymentSchema.index({ payoutStatus: 1, payoutScheduledDate: 1 });

const Payment = mongoose.model("Payment", paymentSchema);

// Create indexes in background
Payment.createIndexes().catch((err) => {
  console.warn("Payment index warning:", err.message);
});

module.exports = Payment;
